#!/usr/bin/env bash
set -uEo pipefail

RED=$'\e[31m'
GREEN=$'\e[32m'
YELLOW=$'\e[33m'
RESET=$'\e[0m'

# Print an error (shell-escaped args) and exit non-zero.
die() {
  printf '%sError:%s' "$RED" "$RESET" >&2
  printf ' %q' "$@" >&2
  printf '\n' >&2
  exit 1
}

# Print a warning to stderr.
warn() { echo "${YELLOW}Warning:${RESET} $*" >&2; }

# Pause execution until the user presses Enter.
pause() { read -r -p "Press Enter to continue..." _; }

# Ensure a required command exists on PATH, otherwise exit.
need_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing dependency: '$1'"
}

# Generic handler for unexpected command failures.
on_err() { warn "Something failed (exit code $?)."; }
trap on_err ERR

# List whole-disk devices in a user-friendly format for selection.
list_disks() {
  # Only whole disks; exclude zram/loop.
  # (mmcblk can stay; it just may not support SMART, but it's still a disk.)
  lsblk -dpno NAME,TYPE,SIZE,MODEL |
    awk '$2=="disk" && $1 !~ /\/dev\/(loop|zram|mmcblk)/ { $2=""; print }'
}

# Present an interactive disk picker; echo selected /dev/... to stdout.
pick_disk() {
  local disks=()
  local line dev

  mapfile -t disks < <(list_disks)
  ((${#disks[@]})) || die "No disks found via lsblk."

  {
    echo
    echo "${YELLOW}Select a disk:${RESET}"
  } >&2

  select line in "${disks[@]}" "Cancel"; do
    case "$REPLY" in
    '' | *[!0-9]*)
      echo "Enter a number." >&2
      continue
      ;;
    esac

    if ((REPLY >= 1 && REPLY <= ${#disks[@]})); then
      dev="${line%% *}"
      printf '%s\n' "$dev" # ONLY stdout output
      return 0
    elif ((REPLY == ${#disks[@]} + 1)); then
      return 1
    else
      echo "${RED}Invalid selection.${RESET}" >&2
    fi
  done
}

# Validate the selected device is a whole-disk block device (and warn if not root).
validate_disk() {
  local dev="$1"
  local type

  type="$(lsblk -dno TYPE "$dev" 2>/dev/null || true)"
  [[ "$type" == "disk" ]] || die "Not a whole disk:" "$dev"

  [[ -b "$dev" ]] || die "Not a block device: $dev"
  [[ "$(lsblk -dno TYPE "$dev" 2>/dev/null)" == "disk" ]] || die "Not a whole disk: $dev"

  # smartctl usually needs root for full info and tests
  if [[ $EUID -ne 0 ]]; then
    warn "Not running as root. You may be prompted for sudo, or smartctl may be limited."
  fi
}

# Run smartctl, using sudo automatically if not root.
run_smartctl() {
  # Runs smartctl via sudo if not root
  if [[ $EUID -eq 0 ]]; then
    smartctl "$@"
  else
    sudo smartctl "$@"
  fi
}

# Start a SMART self-test (short or long) on the selected disk.
start_test() {
  local dev="$1"
  local kind="$2" # short|long

  validate_disk "$dev"

  echo
  echo "${GREEN}Starting $kind self-test on $dev...${RESET}"
  if ! run_smartctl -t "$kind" "$dev"; then
    die "smartctl failed to start the $kind test on $dev"
  fi
}

# Show SMART health/attributes and a simple PASS/FAIL message.
check_health() {
  local dev="$1"

  validate_disk "$dev"

  echo
  echo "${GREEN}SMART health for $dev:${RESET}"
  if ! run_smartctl -H -A "$dev"; then
    die "smartctl health check failed for $dev"
  fi

  if run_smartctl -H "$dev" | grep -qi PASSED; then
    echo "${GREEN}Drive reports HEALTHY.${RESET}"
  else
    echo "${RED}Drive reports PROBLEMS or FAILING state!${RESET}"
  fi
}

# Print the drive's recommended short/long self-test durations.
show_test_times() {
  local dev="$1"

  validate_disk "$dev"

  echo
  echo "${GREEN}Recommended test times for $dev:${RESET}"
  # smartctl -c output differs a bit across drives; this keeps it simple/robust
  if ! run_smartctl -c "$dev" | grep -i -E 'recommended.*self-test|short.*self-test|extended.*self-test|long.*self-test'; then
    warn "Could not extract recommended times. Showing full capabilities output instead:"
    run_smartctl -c "$dev" || true
  fi
}

# Prompt for a yes/no answer; returns 0 for yes, 1 for no.
yes_no() {
  local prompt="$1"
  local ans
  while true; do
    read -r -p "${YELLOW}${prompt}${RESET} [y/N]: " ans
    case "$ans" in
    [yY]) return 0 ;;
    [nN] | "") return 1 ;;
    *) echo "${RED}Invalid selection.${RESET}" ;;
    esac
  done
}

# Menu flow for starting SMART self-tests on disks.
test_disks_menu() {
  while true; do
    local dev
    dev="$(pick_disk)" || return 0

    while true; do
      echo
      echo "${YELLOW}Select test length for $dev:${RESET}"
      select t in "Short" "Long" "Check tests time" "Back"; do
        case "$REPLY" in
        1)
          start_test "$dev" short
          break
          ;;
        2)
          start_test "$dev" long
          break
          ;;
        3)
          show_test_times "$dev"
          pause
          break
          ;;
        4) return 0 ;;
        *) echo "${RED}Invalid selection.${RESET}" ;;
        esac
      done

      echo
      if yes_no "Test another disk?"; then
        break # back to pick_disk
      else
        return 0
      fi
    done
  done
}

# Menu flow for checking SMART health on disks.
check_disks_menu() {
  while true; do
    local dev
    dev="$(pick_disk)" || return 0

    check_health "$dev"
    echo
    if ! yes_no "Check another disk?"; then
      return 0
    fi
  done
}

# Top-level menu routing between test/check actions.
main_menu() {
  while true; do
    echo
    echo "${YELLOW}Disk SMART menu:${RESET}"
    select choice in "Test disks" "Check disks" "Return to main menu"; do
      case "$REPLY" in
      1)
        test_disks_menu
        break
        ;;
      2)
        check_disks_menu
        break
        ;;
      3) return 0 ;;
      *) echo "${RED}Invalid selection.${RESET}" ;;
      esac
    done
  done
}

# ---- entrypoint ----
need_cmd lsblk
need_cmd smartctl
need_cmd awk
need_cmd grep

main_menu

exec "$(dirname "$(dirname "$(realpath "$0")")")/run.sh" -q
